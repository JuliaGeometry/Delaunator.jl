<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · Delaunator.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Delaunator.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/master/docs/src/api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="API-reference"><a class="docs-heading-anchor" href="#API-reference">API reference</a><a id="API-reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-reference" title="Permalink"></a></h1><ul><li><a href="#Delaunator.InfinitePolygon"><code>Delaunator.InfinitePolygon</code></a></li><li><a href="#Delaunator.PointsFromMatrix-Tuple{T} where T&lt;:(AbstractMatrix)"><code>Delaunator.PointsFromMatrix</code></a></li><li><a href="#Delaunator._add_bbox_points-NTuple{5, Any}"><code>Delaunator._add_bbox_points</code></a></li><li><a href="#Delaunator._basictriangulation-NTuple{5, Any}"><code>Delaunator._basictriangulation</code></a></li><li><a href="#Delaunator._get_bounds-Union{Tuple{FloatType}, Tuple{Type{FloatType}, Any}} where FloatType"><code>Delaunator._get_bounds</code></a></li><li><a href="#Delaunator._isright-Tuple{Any, Any, Any}"><code>Delaunator._isright</code></a></li><li><a href="#Delaunator._max_dimension-Tuple{Any}"><code>Delaunator._max_dimension</code></a></li><li><a href="#Delaunator._temporaries-NTuple{9, Any}"><code>Delaunator._temporaries</code></a></li><li><a href="#Delaunator.basictriangulation-Tuple{}"><code>Delaunator.basictriangulation</code></a></li><li><a href="#Delaunator.bbox_intersection-Tuple{Any, Any, Any}"><code>Delaunator.bbox_intersection</code></a></li><li><a href="#Delaunator.bounds-Tuple{Delaunator.AbstractDelaunatorData}"><code>Delaunator.bounds</code></a></li><li><a href="#Delaunator.cellarea-Tuple{Delaunator.InfinitePolygon}"><code>Delaunator.cellarea</code></a></li><li><a href="#Delaunator.circumcenters!-Tuple{Any, Delaunator.AbstractDelaunatorData}"><code>Delaunator.circumcenters!</code></a></li><li><a href="#Delaunator.clippedpoly"><code>Delaunator.clippedpoly</code></a></li><li><a href="#Delaunator.clippedpoly!"><code>Delaunator.clippedpoly!</code></a></li><li><a href="#Delaunator.dualcell-Tuple{Delaunator.Triangulation, Integer}"><code>Delaunator.dualcell</code></a></li><li><a href="#Delaunator.edgelines-Tuple{Delaunator.Triangulation}"><code>Delaunator.edgelines</code></a></li><li><a href="#Delaunator.fast_expansion_sum_zeroelim-Union{Tuple{N}, Tuple{Int64, Any, Int64, Any, Val{N}}} where N"><code>Delaunator.fast_expansion_sum_zeroelim</code></a></li><li><a href="#Delaunator.hullpoly-Tuple{Delaunator.Triangulation}"><code>Delaunator.hullpoly</code></a></li><li><a href="#Delaunator.hullvertices!-Tuple{Any, Delaunator.BasicTriangulation, Delaunator.TriangulationTemporaries}"><code>Delaunator.hullvertices!</code></a></li><li><a href="#Delaunator.index_halfedges!-Tuple{Any, Any, Any}"><code>Delaunator.index_halfedges!</code></a></li><li><a href="#Delaunator.inhull-Tuple{Delaunator.Triangulation, Integer}"><code>Delaunator.inhull</code></a></li><li><a href="#Delaunator.isinfinite"><code>Delaunator.isinfinite</code></a></li><li><a href="#Delaunator.margin_bbox"><code>Delaunator.margin_bbox</code></a></li><li><a href="#Delaunator.orient2-Tuple{Any, Any, Any}"><code>Delaunator.orient2</code></a></li><li><a href="#Delaunator.points-Tuple{Delaunator.AbstractDelaunatorData}"><code>Delaunator.points</code></a></li><li><a href="#Delaunator.rays-Union{Tuple{FloatType}, Tuple{Type{FloatType}, Any, Any}} where FloatType"><code>Delaunator.rays</code></a></li><li><a href="#Delaunator.segments-Tuple{Delaunator.InfinitePolygon}"><code>Delaunator.segments</code></a></li><li><a href="#Delaunator.triangles-Tuple{Delaunator.AbstractDelaunatorData}"><code>Delaunator.triangles</code></a></li><li><a href="#Delaunator.triangles-Tuple{Delaunator.Triangulation, Integer}"><code>Delaunator.triangles</code></a></li><li><a href="#Delaunator.triangulate-Tuple{Any}"><code>Delaunator.triangulate</code></a></li><li><a href="#Delaunator.truncatedcircumcenter-Union{Tuple{FloatType}, NTuple{8, FloatType}, Tuple{FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, Any}} where FloatType"><code>Delaunator.truncatedcircumcenter</code></a></li><li><a href="#Delaunator.update!-Tuple{Any, Delaunator.BasicTriangulation, Delaunator.TriangulationTemporaries}"><code>Delaunator.update!</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="Delaunator.InfinitePolygon" href="#Delaunator.InfinitePolygon"><code>Delaunator.InfinitePolygon</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">InfinitePolygon</code></pre><p>This is the type we use to represent dual cells / Voronoi cells. It&#39;s a possibly infinite polygon stored as an array of points with optional head and tail rays. </p><p>Methods</p><ul><li><a href="#Delaunator.segments-Tuple{Delaunator.InfinitePolygon}"><code>segments</code></a> to get the line segments for the polygon.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL3-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.PointsFromMatrix-Tuple{T} where T&lt;:(AbstractMatrix)" href="#Delaunator.PointsFromMatrix-Tuple{T} where T&lt;:(AbstractMatrix)"><code>Delaunator.PointsFromMatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PointsFromMatrix(A [,i1=1,i2=2])</code></pre><p>This implicitly extracts 2d point tuples from a matrix using row indices i1 and i2 for the coordinates. The columns of the matrix because individual points. </p><pre><code class="nohighlight hljs">PointsFromMatrix(A) == vec(reinterpret(Tuple{Int,Int},A[1:2,:]))</code></pre><p>This function can be used to transparently map a matrix into a Delaunator set of points. (There is no copying involved).</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">A = reshape(1:20, 4, 5)
rval = triangulate(PointsFromMatrix(A))) # uses A[1:2,:]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/helpers.jl#LL7-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.contains-Tuple{Delaunator.InfinitePolygon, Any}" href="#Base.contains-Tuple{Delaunator.InfinitePolygon, Any}"><code>Base.contains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">contains(p::InfinitePolygon, pt)</code></pre><p>Test if the infinite polygon contains a point.     The point type pt must be able to be iterated to a pair      of numbers </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL93-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.eachindex-Tuple{Delaunator.AbstractDelaunatorData}" href="#Base.eachindex-Tuple{Delaunator.AbstractDelaunatorData}"><code>Base.eachindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eachindex(t::AbstractDelaunatorData)</code></pre><p>Return the indicies of each point in the dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL95-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isfinite" href="#Base.isfinite"><code>Base.isfinite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isfinite(poly)
isinfinite(poly)</code></pre><p>Test if the polygon is infinite or finite. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator._add_bbox_points-NTuple{5, Any}" href="#Delaunator._add_bbox_points-NTuple{5, Any}"><code>Delaunator._add_bbox_points</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Walk the corners by their region codes to find points on the bounding box to add as we move from outside the bbox back inside...</p><pre><code class="nohighlight hljs">  # This is the order of codes in counter-clockwise order. 
  # Top-Left        Top         Top-Right
  # 1001     &lt;-     1000    &lt;-  1010
  #   |                           ^
  #   v                           |
  # 0001                         0010
  # Left                         Right 
  #   |                           ^
  #   v                           |  
  # 0101     -&gt;    0100     -&gt;  0110
  # Bottom Left   Bottom       Bottom right 
  # 
  # bottom right means x &gt;= xmax (0010) and y &lt;= ymin (0100)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/clipping.jl#LL231-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator._basictriangulation-NTuple{5, Any}" href="#Delaunator._basictriangulation-NTuple{5, Any}"><code>Delaunator._basictriangulation</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a function to simplify type management. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator._get_bounds-Union{Tuple{FloatType}, Tuple{Type{FloatType}, Any}} where FloatType" href="#Delaunator._get_bounds-Union{Tuple{FloatType}, Tuple{Type{FloatType}, Any}} where FloatType"><code>Delaunator._get_bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Calculate upper and lowerbounds on the coordinates in points. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/algorithm.jl#LL1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator._isright-Tuple{Any, Any, Any}" href="#Delaunator._isright-Tuple{Any, Any, Any}"><code>Delaunator._isright</code></a> — <span class="docstring-category">Method</span></header><section><div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator._max_dimension-Tuple{Any}" href="#Delaunator._max_dimension-Tuple{Any}"><code>Delaunator._max_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Get the largest distance along x or y dimension. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL386">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator._temporaries-NTuple{9, Any}" href="#Delaunator._temporaries-NTuple{9, Any}"><code>Delaunator._temporaries</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Create a wrapper to simplify type management. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.basictriangulation-Tuple{}" href="#Delaunator.basictriangulation-Tuple{}"><code>Delaunator.basictriangulation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bt, cdata = basictriangulation(IntType=Int32,] [FloatType=Float64,] [points];[sizehint=length(points),] [tol])</code></pre><p>Allocate a basic triangulation structure and associated compute data in order to implement the Deluantor method. </p><p><strong>This method does not actaully compute a triangulation, but only allocates the data. See <code>triangulate</code> or <code>update!</code> for the computational methods.</strong></p><p><strong>The triangulation data structure</strong></p><p>These data structures are explained at https://mapbox.github.io/delaunator/  (but here, all the indices have been modified a little).</p><ul><li><code>triangles</code>: a length T array of 3 tuples, where each tuple is a triangle</li><li><code>halfedges</code>: The halfedge index for the edge in the triangle array. The halfedges for    triangle t are 3(t-1)+1, 3(t-1)+2, 3(t-2)+3. Each halfedge index gives the entry   of the other halfedge. </li><li><code>points</code> a copy of the input set of points</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL192-L211">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.bbox_intersection-Tuple{Any, Any, Any}" href="#Delaunator.bbox_intersection-Tuple{Any, Any, Any}"><code>Delaunator.bbox_intersection</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Compute intersections between the bbox and a point and ray combo. Or on the line between two points.  For a line intersection, use tmin=0, tmax=1. For a ray intersection, use tmin=0, tmax=Inf. </p><p>This will return the origin point (pt) if there  are no intersections with the bbox. This will return a duplicated point if there is only a single intersection.</p><p>These return a coordinate that is guaranteed to be on the bbox, unless the return value is pt. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/clipping.jl#LL90-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.bounds-Tuple{Delaunator.AbstractDelaunatorData}" href="#Delaunator.bounds-Tuple{Delaunator.AbstractDelaunatorData}"><code>Delaunator.bounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minpt, maxpt = bounds(t::AbstractDelaunatorData)</code></pre><p>Return the coordinate bounds on the points. All of the points (as of the computation of the algorithm) lie within minpt &lt;= pt &lt;= maxpt. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL114-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.cellarea-Tuple{Delaunator.InfinitePolygon}" href="#Delaunator.cellarea-Tuple{Delaunator.InfinitePolygon}"><code>Delaunator.cellarea</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cellarea(p)</code></pre><p>Compute the area of a possibly infinite polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.circumcenters!-Tuple{Any, Delaunator.AbstractDelaunatorData}" href="#Delaunator.circumcenters!-Tuple{Any, Delaunator.AbstractDelaunatorData}"><code>Delaunator.circumcenters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">circumcenters!(array, bt; [collinearthresh=0])</code></pre><p>Write information on the circumcenters into array. Array must  have length(bt.triangles) allocated. <code>collinearthresh</code> is an  option that </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL392-L398">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.clippedpoly" href="#Delaunator.clippedpoly"><code>Delaunator.clippedpoly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clippedpoly(p::InfinitePolygon, bbox; [closed=true])
clippedpoly!(pts, p::InfinitePolygon, bbox)</code></pre><p>returns an empty array if the poly is entirely outside the bounding box. Otherwise, return a set of points that represent edges of the infinite polygon clipped to the bounding box. The set of points will  be closed (where the first point is equal to the last) if the closed=true option is set. The set of points <em>may</em> be closed even if this isn&#39;t set. Using closed=true results in simpler behavior. This is not an option on the mutating version, see below for how to get this functionality.  </p><p>The mutating version will update the pts array by using</p><pre><code class="nohighlight hljs">- `push!(pts, &lt;newpt&gt;)` 
- `last(pts)`
- `isempty(pts)`</code></pre><p>It will return the input type pts. </p><p><strong>Example code</strong></p><pre><code class="nohighlight hljs"># generate polygon regions for all of the dualcells 
# clipped to a 5% expansion of the point bounding box
# as a list of NaN separated paths, with all 
# polygons closed. 
using GeometryBasics
t = triangulate(rand(Point2f, 15))
ppts = Point2f[]
for i in eachindex(t)
    ind = lastindex(ppts)
    clippedpoly!(ppts, dualcell(t, i), margin_bbox(t, 0.05))
    # check if the polygon was closed... 
    if lastindex(ppts) &gt; ind # then we added point
        if ppts[ind+1] != ppts[end] # check if we are closed
            push!(ppts, ppts[ind+1]) # close the polygon
        end 
    end 
    push!(ppts, (NaN,NaN)) # add the NaN separator 
end </code></pre><p>See also <a href="#Delaunator.dualcell-Tuple{Delaunator.Triangulation, Integer}"><code>dualcell</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/clipping.jl#LL25-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.clippedpoly!" href="#Delaunator.clippedpoly!"><code>Delaunator.clippedpoly!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">clippedpoly(p::InfinitePolygon, bbox; [closed=true])
clippedpoly!(pts, p::InfinitePolygon, bbox)</code></pre><p>returns an empty array if the poly is entirely outside the bounding box. Otherwise, return a set of points that represent edges of the infinite polygon clipped to the bounding box. The set of points will  be closed (where the first point is equal to the last) if the closed=true option is set. The set of points <em>may</em> be closed even if this isn&#39;t set. Using closed=true results in simpler behavior. This is not an option on the mutating version, see below for how to get this functionality.  </p><p>The mutating version will update the pts array by using</p><pre><code class="nohighlight hljs">- `push!(pts, &lt;newpt&gt;)` 
- `last(pts)`
- `isempty(pts)`</code></pre><p>It will return the input type pts. </p><p><strong>Example code</strong></p><pre><code class="nohighlight hljs"># generate polygon regions for all of the dualcells 
# clipped to a 5% expansion of the point bounding box
# as a list of NaN separated paths, with all 
# polygons closed. 
using GeometryBasics
t = triangulate(rand(Point2f, 15))
ppts = Point2f[]
for i in eachindex(t)
    ind = lastindex(ppts)
    clippedpoly!(ppts, dualcell(t, i), margin_bbox(t, 0.05))
    # check if the polygon was closed... 
    if lastindex(ppts) &gt; ind # then we added point
        if ppts[ind+1] != ppts[end] # check if we are closed
            push!(ppts, ppts[ind+1]) # close the polygon
        end 
    end 
    push!(ppts, (NaN,NaN)) # add the NaN separator 
end </code></pre><p>See also <a href="#Delaunator.dualcell-Tuple{Delaunator.Triangulation, Integer}"><code>dualcell</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/clipping.jl#LL25-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.dualcell-Tuple{Delaunator.Triangulation, Integer}" href="#Delaunator.dualcell-Tuple{Delaunator.Triangulation, Integer}"><code>Delaunator.dualcell</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dualcell(t, i)
dualcell(t, centers, i)</code></pre><p>Return the finite or infinite polygon description of the dual cell to a given point index in the triangulation. The dual cell is the  Voronoi cell to a Delaunay triangulation. </p><p>The default usage uses the circumcenters of the Delaunay triangles  as the coordinates of the Voroni vertices. However,  you can override this by giving another collection of centers.  The number of centers must be equal to the number  of triangles. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL219-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.edgelines-Tuple{Delaunator.Triangulation}" href="#Delaunator.edgelines-Tuple{Delaunator.Triangulation}"><code>Delaunator.edgelines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">edgelines(t::Triangulation)</code></pre><p>Return a generator that can be used with Makie&#39;s linesegments function to  display the edges of the triangulation. Each edge is only drawn once.</p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">using GLMakie
t = triangulate(rand(StableRNG(1), Point2f, 10))
linesegments(collect(edgelines(rval)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/iterators.jl#LL60-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.fast_expansion_sum_zeroelim-Union{Tuple{N}, Tuple{Int64, Any, Int64, Any, Val{N}}} where N" href="#Delaunator.fast_expansion_sum_zeroelim-Union{Tuple{N}, Tuple{Int64, Any, Int64, Any, Val{N}}} where N"><code>Delaunator.fast_expansion_sum_zeroelim</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Sets h = e + f.  See the long version of my paper for details. 

If round-to-even is used (as with IEEE 754), maintains the strongly
nonoverlapping property.  (That is, if e is strongly nonoverlapping, h
will be also.)  Does NOT maintain the nonoverlapping or nonadjacent
properties.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/robust.jl#LL384-L391">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.hullpoly-Tuple{Delaunator.Triangulation}" href="#Delaunator.hullpoly-Tuple{Delaunator.Triangulation}"><code>Delaunator.hullpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hullpoly(t)</code></pre><p>Return the coordinates of the convex hull suitable for plotting as a polygon. </p><p><strong>Example</strong></p><pre><code class="nohighlight hljs">t = triangulate(rand(StableRNG(1), Point2f, 10))
f = scatter(t.points)
poly!(f.axis,collect(hullpoly(t)),color=:transparent, strokewidth=1)
f</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/iterators.jl#LL81-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.hullvertices!-Tuple{Any, Delaunator.BasicTriangulation, Delaunator.TriangulationTemporaries}" href="#Delaunator.hullvertices!-Tuple{Any, Delaunator.BasicTriangulation, Delaunator.TriangulationTemporaries}"><code>Delaunator.hullvertices!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hullvertices!(hull, bt, cdata)</code></pre><p>After an <a href="#Delaunator.update!-Tuple{Any, Delaunator.BasicTriangulation, Delaunator.TriangulationTemporaries}"><code>update!</code></a> call, we can use the data structures to get a simple list of vertices on the convex hull. This routine will run <code>push!(hull, v)</code> for each vertex on the convex hull.  The order will be in order around the hull. This returns the hull variable. </p><p>This is part of the advanced interface. See  <a href="#Delaunator.triangulate-Tuple{Any}"><code>triangulate</code></a> which returns a more complete data structure including the hull information automatically. </p><p><strong>Sample calls</strong></p><pre><code class="language-julia-repl hljs">julia&gt; using Delaunator, StableRNGs, GeometryBasics
julia&gt; bt, cdata = basictriangulation(pts)
julia&gt; hull = hullvertices!(Vector{Int}, bt, cdata )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL312-L331">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.index_halfedges!-Tuple{Any, Any, Any}" href="#Delaunator.index_halfedges!-Tuple{Any, Any, Any}"><code>Delaunator.index_halfedges!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Store the first time a point occurs in halfedges into the index. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.inhull-Tuple{Delaunator.Triangulation, Integer}" href="#Delaunator.inhull-Tuple{Delaunator.Triangulation, Integer}"><code>Delaunator.inhull</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">inhull(t::Triangulation, i::Integer)</code></pre><p>Return the index of the vertex in the list of hull vertices (t.hull)  if it&#39;s in the hull, or zero if the vertex is not in the hull. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL104-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.isinfinite" href="#Delaunator.isinfinite"><code>Delaunator.isinfinite</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">isfinite(poly)
isinfinite(poly)</code></pre><p>Test if the polygon is infinite or finite. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL49-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.margin_bbox" href="#Delaunator.margin_bbox"><code>Delaunator.margin_bbox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bbox = margin_bbox(t, [margin])
bbox = margin_bbox(t, xmargin, ymargin)</code></pre><p>Returns a bounding box (bbox) for the triangulation after applying a margin. The default value of margin is 0.05. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/clipping.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.orient2-Tuple{Any, Any, Any}" href="#Delaunator.orient2-Tuple{Any, Any, Any}"><code>Delaunator.orient2</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a positive value if the points pa, pb, and pc occur in counterclockwise order a negative value if they occur in clockwise order and zero if they are collinear.  The result is also a rough approximation of twice the signed area of the triangle defined by the three points.                                                             </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/robust.jl#LL90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.points-Tuple{Delaunator.AbstractDelaunatorData}" href="#Delaunator.points-Tuple{Delaunator.AbstractDelaunatorData}"><code>Delaunator.points</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">points(t::AbstractDelaunatorData)</code></pre><p>Return the point coordinates that were given as input to the algorithm.  Note that changing these does not dynamically change the triangulation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL84-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.rays-Union{Tuple{FloatType}, Tuple{Type{FloatType}, Any, Any}} where FloatType" href="#Delaunator.rays-Union{Tuple{FloatType}, Tuple{Type{FloatType}, Any, Any}} where FloatType"><code>Delaunator.rays</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">raystart, rayend = rays(t)</code></pre><p>This returns arrays that are indexed by the <em>index of</em> a point on the convex hull. So to get the infinite rays associated with the nearest point cell use:</p><pre><code class="nohighlight hljs">function rays_for_point(t)
    rs, re = rays(t) # only need to compute this one 
    hullindex = inhull(t, i)
    if hullindex &gt; 0 
        return rs[hullindex],re[hullindex]
    else
        return 
    end 
end </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL424-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.segments-Tuple{Delaunator.InfinitePolygon}" href="#Delaunator.segments-Tuple{Delaunator.InfinitePolygon}"><code>Delaunator.segments</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">segments(p::InfinitePolygon; [dist = eps()])</code></pre><p>Return an iterator over linesegments involved in the polygon. If the polygon is infinite, then this will not be closed and the first two points will be along the incoming ray and the last two points will be along the outgoing ray (each will be an arbitrary  length along this ray)</p><p>If the polygon is finite, then it will be closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL203-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.triangles-Tuple{Delaunator.AbstractDelaunatorData}" href="#Delaunator.triangles-Tuple{Delaunator.AbstractDelaunatorData}"><code>Delaunator.triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangles(t::AbstractDelaunatorData)</code></pre><p>Return the point indices for each triangle in the triangulation.     </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL75-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.triangles-Tuple{Delaunator.Triangulation, Integer}" href="#Delaunator.triangles-Tuple{Delaunator.Triangulation, Integer}"><code>Delaunator.triangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangles(t, i)</code></pre><p>Given a Triangulation and a point index <code>i</code>, return an iterator over the indices of triangles that include point i. These are returned in counter-clockwise order. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/iterators.jl#LL147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.triangulate-Tuple{Any}" href="#Delaunator.triangulate-Tuple{Any}"><code>Delaunator.triangulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">triangulate([Int32,] [FloatType=Float64,] points; [tol=eps(FloatType),])</code></pre><p>Computes a triangulation of a set of points using the Delaunator algorithm. This is designed for quick graphics applications and speed rather than exact computational geometry.</p><p><strong>Inputs</strong></p><ul><li><p><code>points</code> is any type that has integer indexing and length supported. In addition, <code>p = points[i]</code> should    be a type where <code>p[1]</code> and <code>p[2]</code> are the x, y coordinates of p. Or you need to define the functions    <code>Delaunator.getX(p), Delaunator.getY(p)</code> for your own type p. </p><p>If you wish to use a a matrix to give the point information, <a href="#Delaunator.PointsFromMatrix-Tuple{T} where T&lt;:(AbstractMatrix)"><code>PointsFromMatrix</code></a></p></li><li><p><code>tol</code> is used to determine when points are sufficiently close not to include</p></li></ul><p><strong>Return value</strong></p><p>A triangulation, with methods to explore edges, hull points, dual cells.</p><p>See also <a href="#Delaunator.basictriangulation-Tuple{}"><code>basictriangulation</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL473-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.truncatedcircumcenter-Union{Tuple{FloatType}, NTuple{8, FloatType}, Tuple{FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, Any}} where FloatType" href="#Delaunator.truncatedcircumcenter-Union{Tuple{FloatType}, NTuple{8, FloatType}, Tuple{FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, FloatType, Any}} where FloatType"><code>Delaunator.truncatedcircumcenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">truncatedcircumcenter</code></pre><p>For a nearly collinear triangle, then the circumcenter can be off at a point near infinity. Since the goal of this library is not computational geometry, a pragmatic choice is to truncate these wildly divergent near infinite circumcenters. </p><p>function from d3-delaunay / Voronoi.js</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/geometry.jl#LL356-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Delaunator.update!-Tuple{Any, Delaunator.BasicTriangulation, Delaunator.TriangulationTemporaries}" href="#Delaunator.update!-Tuple{Any, Delaunator.BasicTriangulation, Delaunator.TriangulationTemporaries}"><code>Delaunator.update!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">bt, cdata = update!(points, bt, cdata)</code></pre><p>Reuse the memory and arrays to update the triangulation. Note that the resulting return values may be new as this routine can allocate new arrays if needed to handle the updated set of points. This implements the key step of the Delaunator method. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGeometry/Delaunator.jl/blob/c066b043f5c704a42cf3e77849ba52fea346718b/src/interface.jl#LL230-L236">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 30 July 2024 19:54">Tuesday 30 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
